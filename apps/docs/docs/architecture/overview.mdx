---
sidebar_position: 1
title: Vue d'ensemble
description: Architecture globale du système Maison Amane
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Vue d'ensemble de l'architecture

Maison Amane est une application e-commerce construite sur les principes du **Domain-Driven Design (DDD)** et de l'**architecture hexagonale**. Le système utilise un pattern **CQRS** (Command Query Responsibility Segregation) avec **event sourcing partiel** pour séparer les opérations d'écriture des opérations de lecture.

## Diagramme d'architecture

```mermaid
flowchart TB
    subgraph Client["Client Layer"]
        HTTP_CMD["POST /api/pilot-product<br/>PUT /api/pilot-product/:id"]
        HTTP_QUERY["GET /api/pilot-product/:id"]
        HTTP_MEDIA["POST /api/media"]
    end

    subgraph Server["Server (Write Model)"]
        Handler["HTTP Handlers"]
        AppHandler["Application Handlers"]
        Publisher["Event Publisher"]
        PilotAggregate["PilotProduct<br/>(Aggregate)"]
        MediaAggregate["Media<br/>(Aggregate)"]
        PilotRepo["PilotProductRepository"]
        MediaRepo["MediaRepository"]
    end

    subgraph Persistence["Persistence"]
        MongoDB_Catalog[(MongoDB<br/>catalog_products)]
        MongoDB_Media[(MongoDB<br/>media)]
        MongoDB_Pilot[(MongoDB<br/>pilot_products)]
    end

    subgraph Messaging["Messaging (RabbitMQ)"]
        Exchange{{"pilot.events<br/>(Exchange)"}}
        CatalogQueue["catalog-projection.queue"]
        ShopifyQueue["shopify-sync.queue"]
        MediaQueue["media-confirmation.queue"]
    end

    subgraph Consumers["Consumers"]
        ShopifyConsumer["Shopify Sync"]
        CatalogConsumer["Catalog Projection"]
        MediaConsumer["Media Confirmation"]
    end

    subgraph External["External Services"]
        Shopify["Shopify API"]
    end

    HTTP_CMD --> Handler
    HTTP_QUERY --> Handler
    HTTP_MEDIA --> Handler
    Handler --> AppHandler
    AppHandler -->|"Events"| Publisher
    AppHandler --> PilotAggregate
    AppHandler --> MediaAggregate
    Publisher --> Exchange
    PilotAggregate --> PilotRepo
    MediaAggregate --> MediaRepo
    PilotRepo --> MongoDB_Pilot
    MediaRepo --> MongoDB_Media

    Exchange -->|"product.published<br/>product.updated"| ShopifyQueue
    Exchange -->|"product.published<br/>product.updated"| CatalogQueue
    Exchange -->|"product.created"| MediaQueue

    ShopifyQueue --> ShopifyConsumer
    ShopifyConsumer --> Shopify
    ShopifyConsumer -->|"Update syncStatus"| MongoDB_Pilot

    CatalogQueue --> CatalogConsumer
    CatalogConsumer --> MongoDB_Catalog

    MediaQueue --> MediaConsumer
    MediaConsumer -->|"Confirm media"| MongoDB_Media

    classDef primary fill:#2e5d4e,stroke:#1f4139,color:#fff
    classDef secondary fill:#5ba88a,stroke:#3c7962,color:#fff
    classDef storage fill:#f5f5f5,stroke:#333,color:#333
    classDef messaging fill:#ff9800,stroke:#e65100,color:#fff
    classDef external fill:#2196f3,stroke:#0d47a1,color:#fff

    class Handler,AppHandler,PilotAggregate,MediaAggregate,PilotRepo,MediaRepo,Publisher primary
    class CatalogConsumer,ShopifyConsumer,MediaConsumer secondary
    class MongoDB_Pilot,MongoDB_Catalog,MongoDB_Media storage
    class Exchange,CatalogQueue,ShopifyQueue,MediaQueue messaging
    class Shopify external
```

:::tip Gestion des erreurs
Chaque consumer dispose d'un mécanisme de retry automatique et d'une Dead Letter Queue (DLQ). Voir [Gestion des erreurs](./data-flows/error-handling) pour les détails.
:::

## Composants principaux

<Tabs>
  <TabItem value="server" label="Server (API)" default>

Le serveur HTTP gère les **commandes d'écriture** et les **queries de lecture**.

| Composant | Rôle | Endpoints |
|-----------|------|-----------|
| Pilot Product Handlers | Création, mise à jour et consultation de produits | `POST`, `PUT`, `GET /api/pilot-product` |
| Media Handler | Enregistrement de médias (images) | `POST /api/media` |
| Application Handlers | Orchestration métier, émission d'événements | - |
| Event Publisher | Publication des événements vers RabbitMQ | - |

  </TabItem>
  <TabItem value="consumers" label="Consumers">

Les consumers sont des **driving adapters asynchrones** : ils reçoivent des événements depuis RabbitMQ et déclenchent des use cases applicatifs.

| Consumer | Événements écoutés | Rôle |
|----------|-------------------|------|
| `catalog-projection` | `product.published`, `product.updated` | Projette vers CatalogProduct |
| `shopify-sync` | `product.published`, `product.updated` | Synchronise vers Shopify |
| `media-confirmation` | `product.created` | Confirme les médias référencés |

**Flux** : `RabbitMQ Event → Consumer (driving) → Application Handler → Repository (driven)`

  </TabItem>
  <TabItem value="messaging" label="Messaging">

Le système de messaging utilise **RabbitMQ** avec une topologie topic-based.

| Élément | Nom | Description |
|---------|-----|-------------|
| Exchange principal | `pilot.events` | Reçoit tous les événements domaine |
| Routing key | `product.created` | Événement de création |
| Routing key | `product.published` | Événement de publication |
| Routing key | `product.updated` | Événement de mise à jour |

  </TabItem>
</Tabs>

## Principes architecturaux

### CQRS (Command Query Responsibility Segregation)

Le système sépare :
- **Write Model** : PilotProduct (agrégat complet, validation métier)
- **Read Model** : CatalogProduct (projection optimisée pour l'affichage)

Cette séparation permet :
- D'optimiser chaque modèle pour son usage
- De scaler indépendamment lecture et écriture
- D'évoluer les modèles séparément

### Event Sourcing partiel

Les événements domaine sont utilisés pour :
- Déclencher les projections (Catalog)
- Déclencher les intégrations (Shopify)
- Confirmer les médias référencés
- Assurer la traçabilité (correlationId)

:::note
Le système n'implémente pas un event store complet. Les événements ne sont pas persistés comme source de vérité, mais utilisés pour la communication asynchrone.
:::

### Architecture hexagonale

```mermaid
flowchart TB
    subgraph Driving["Driving Adapters (Ports d'entrée)"]
        HTTP["HTTP Handler<br/>(infrastructure/http/)"]
        Consumer["Message Consumers<br/>(apps/consumers/)"]
    end

    subgraph Core["Application Core"]
        UseCase["Application Handlers<br/>(application/*/handlers/)"]
        Domain["Domain Model<br/>(domain/)"]
    end

    subgraph Driven["Driven Ports + Adapters (Ports de sortie)"]
        RepoPort["Repository Port"]
        EventPort["EventPublisher Port"]
        ShopifyPort["ShopifyClient Port"]

        RepoImpl["MongoDB Implementation"]
        EventImpl["RabbitMQ Implementation"]
        ShopifyImpl["Shopify API Implementation"]
    end

    HTTP -->|"appelle"| UseCase
    Consumer -->|"appelle"| UseCase
    UseCase -->|"manipule"| Domain
    UseCase -->|"dépend de"| RepoPort
    UseCase -->|"dépend de"| EventPort
    UseCase -->|"dépend de"| ShopifyPort

    RepoPort -.->|"implémente"| RepoImpl
    EventPort -.->|"implémente"| EventImpl
    ShopifyPort -.->|"implémente"| ShopifyImpl

    RepoImpl -->|"accès"| MongoDB[(MongoDB)]
    EventImpl -->|"publish"| RabbitMQ[(RabbitMQ)]
    ShopifyImpl -->|"API call"| Shopify[Shopify API]

    classDef driving fill:#2e5d4e,stroke:#1f4139,color:#fff
    classDef core fill:#5ba88a,stroke:#3c7962,color:#fff
    classDef port fill:#f5f5f5,stroke:#666,color:#333,stroke-dasharray: 5 5
    classDef adapter fill:#e0e0e0,stroke:#999,color:#333

    class HTTP,Consumer driving
    class UseCase,Domain core
    class RepoPort,EventPort,ShopifyPort port
    class RepoImpl,EventImpl,ShopifyImpl adapter
```

#### Structure des ports

**Driven Ports** (`ports/driven/`) : interfaces pour les dépendances externes

| Port | Interface | Implémentation Dev | Implémentation Test |
|------|-----------|-------------------|---------------------|
| Repository (Pilot) | `PilotProductRepository` | MongoDB | In-Memory |
| Repository (Media) | `MediaRepository` | MongoDB | In-Memory |
| Event Publisher | `EventPublisher` | RabbitMQ | Spy (mock) |
| Shopify Client | `ShopifyClient` | Fake (mock) | Fake |
| ID Generator | `IdGenerator` | UUID v4 | Deterministic |
| Clock | `Clock` | System time | Fixed time |

**Driving Ports** (`ports/driving/`) : **vide, et c'est normal**

:::info Pourquoi ports/driving/ est vide ?
Avec Effect-TS, les **application handlers** sont déjà des contrats grâce au typage structurel :

```typescript
// Ceci EST un contrat implicite :
handlePilotProductCreation: (cmd: CreatePilotProductCommand) =>
  Effect<PilotProduct, DomainError, PilotProductRepository | IdGenerator>
```

Les driving adapters (HTTP handlers, consumers) importent directement ces handlers.

**Pas besoin d'interfaces explicites** sauf si vous avez besoin de :
- Versioning (use case v1 vs v2)
- Multi-tenancy avec logiques différentes
- A/B testing avec swap d'implémentations
:::

#### Flux de dépendances

```
Requête HTTP ou Event RabbitMQ
        ↓
Driving Adapter (HTTP/Consumer)
        ↓
Application Handler (use case)
        ↓
Domain Model (aggregate)
        ↓
Driven Ports (interfaces)
        ↓
Infrastructure (implémentations)
```

Pour la stack technique et la structure du monorepo, voir l'[Introduction](../intro).
